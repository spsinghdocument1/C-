#include <vector>
#include <stdio.h>
#include <string.h>
#include <vector>
#include <map>
#include <arpa/inet.h>
#include "Struct.h"


#include <fstream>
#include <assert.h>
#include <nanomsg/nn.h>
#include <nanomsg/pubsub.h>
#include<iostream>
#include <unistd.h>
#include <pthread.h>
#include <cstdlib>
#include<stdio.h>


using namespace std;




//#ifndef EVENTCLASS_H
#define	EVENTCLASS_H

extern "C"
{
    typedef void ( * ProgressCallback)( char*,int);
    void PassRefOfMethod(ProgressCallback progressCallback,long ClientID);
     void DisposeCPP();
}

namespace AutoClient
{



class AutoClientFoFo
{




	map<int, FinalPrice> _Datadict;
	map<int, NFToken> SymbolDictionary;
	map<int,struct FOPAIRDIFF> _FOPAIRDIFF ;

	map<int, OrderDetails> _OrderDetailsBuy;
	map<int, OrderDetails> _OrderDetailsSell;
//	map<int, map<char, OrderDetails>> _OrderDetails
	map<int,  NearMonthPacket> _NMPACK;

//#define CancelCode 20070
//#define ModificationCode 20070
//*************************************************

	short  CancelCode;
	short  ModificationCode;
	long UserId;//Trader
	short BranchId;

	int BrokerId;


//	MS_OE_REQUEST_TR OEObj;
//	MS_OM_REQUEST_TR OMObj;

      //  MS_OE_REQUEST obj_MS_OE_REQ;
      //  MS_OE_RESPONSE_TR obj_Ms_Oe_res_tr;//156
      //  MS_TRADE_CONFIRM_TR obj_Tradeconf_tr;
      //  MS_OE_REQUEST_TR obj_Ms_Oe_req_tr;

public:    bool IsExit;
    ProgressCallback ProcessToEnqueue;
    long ClientIdAuto;
public:
	AutoClientFoFo()
	{


	}

	void InItClass()
	{

start(params);

	IsExit=false;
		CancelCode=ntohs(20070);
		ModificationCode=ntohs(20040);

	// BrokerId=12468;

	 BranchId=1;    //252
	 UserId=32865;

   //BranchId=4;    //227
    //UserId=31620;
    Contract_Filefun();
	}



	/////////

//pthread_mutex_t mutex2;


//	public:
 void start(void *params)
 {


  this->params = params;
  pthread_create (&threadId, 0, runDatasubscriber, static_cast<void*>(this));
  pthread_create (&threadId, 0, runEventsubscriber, static_cast<void*>(this));
  cout << "start End" << endl;
 }

private:
  static void *runDatasubscriber(void *my_object)
  {
   static_cast<AutoClientFoFo*>(my_object)->Datasubscriber(my_object);
  }
   static void *runEventsubscriber(void *my_object)
  {
    static_cast<AutoClientFoFo*>(my_object)->Eventsubscriber(my_object);
  }



private:
    pthread_t threadId;
    void *params;




	/////////






	 void PadRight(char *string, int padded_len, char *pad)
	 {
            int len = (int) strlen(string);
            if (len >= padded_len) {
            //return string;
            }
            int i;
            for (i = 0; i < padded_len - len; i++) {
            strcat(string, pad);
            }
        //  return string;

    }

void toUpper(char* pArray, int arrayLength)
{
    for(int i = 0; i < arrayLength; i++)
    {
        if(pArray[i] >= 'a' && pArray[i] <= 'z')
            pArray[i] -= ' ';
    }
}



		///Contract File Loading....begin
		vector<struct Contract_File> cimlist;
	//	vector<struct Contract_File> first;
	void Contract_Filefun()
	{

		Contract_File obj;
		char delimiter = '|';
		string line;
		string row[100];
		string acc = "";
		int cnt = 0;
		ifstream myfile;
		myfile.open("/root/Desktop/contract.txt");
      // myfile.open("/root/Documents/Pradeep/NanoMQ/NNFServerTest/contract.txt");


		while (getline(myfile, line))
		{

			int c = 0;
			for (int i = 0; i < line.length(); i++)
			{
				if (line[i] == ',' || line[i] == '|')
				{

					row[c] = acc;
					c++;


					acc = "";

				}
				else
				{
					acc += line[i];

				}
			}
			row[c] = acc;

			if (cnt == 0)
			{

				obj.NEATFO = row[0];

				obj.VersionNumber = row[1];
				cimlist.push_back(obj);




			}
			else
			{
				int j = 0;


				obj.Token = atol(row[j++].c_str());
				obj.AssetToken = atol(row[j++].c_str());

				obj.InstrumentName = row[j++];
				obj.Symbol = row[j++];
				obj.Series = row[j++];
				j++;
				obj.ExpiryDate = atol(row[j++].c_str());
				obj.StrikePrice = atol(row[j++].c_str());
				obj.OptionType = row[j++];
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				j++;
				obj.BoardLotQuantity  = atol(row[j++].c_str());

				cimlist.push_back(obj);
			}
			cnt++;
			line = "";
		}


		myfile.close();
	cout<<"Contract_Filefun Loaded"<<": cnt="<<cnt<<endl;
	}

		////contract File Loading.....End

		///here InitTokenDetails Call..../////////


		TokenPartnerDetails  InitTokenDetails( int FirstLeg, int alternateLeg, int PortfolioName)
	{

		 TokenPartnerDetails tpdobj;

		/*if (TokenPartner.find(FirstLeg) != TokenPartner.end())
		{
			cout << "Token already exists" << endl;
			return TokenPartner;

		}*/


	//	vector<Contract_File> san_contract = cimlist; //CSV_Class.cimlist.Where (a => a.Token == FirstLeg).ToList ();

		if (cimlist.empty())
		{
			cout << "Contract holder empty" << endl;
			return tpdobj;

		}


		for (vector<Contract_File>::iterator it = cimlist.begin(); it != cimlist.end(); it++)
		{


			struct Contract_File *cf =new Contract_File();


			if (it->Token == FirstLeg)
			{

				tpdobj.CF.Token = it->Token;
				tpdobj.CF.AssetToken = it->AssetToken;
				tpdobj.CF.InstrumentName = it->InstrumentName;
				tpdobj.CF.Symbol = it->Symbol;
				tpdobj.CF.Series = it->Series;
				tpdobj.CF.ExpiryDate = it->ExpiryDate;
				tpdobj.CF.OptionType = it->OptionType;
				tpdobj.CF.BoardLotQuantity=it->BoardLotQuantity;
				tpdobj.PartnerLeg = alternateLeg;
            	tpdobj.PortfolioName = PortfolioName;


			}


		}

		return tpdobj;

	}

///Start ReturnPack................................



public:

//char *
MS_OE_REQUEST_TR ReturnNearPack(int Token,BUYSELL BS,int Qty)
{
            //MS_OE_REQUEST_TR obj2;
		    //****we use dll for below line..................
		    //var _contract = CSV_Class.cimlist.Where (a => a.Token == Token).ToList ();


 MS_OE_REQUEST_TR obj2;
   for (vector<Contract_File>::iterator it2 = cimlist.begin(); it2 != cimlist.end(); it2++)
		{
			if (it2->Token == Token)
			{
			strncpy(obj2.InstrumentName,it2->InstrumentName.c_str(),sizeof(obj2.InstrumentName));
			//obj2.InstrumentName=it2->InstrumentName;
			strncpy(obj2.Symbol,it2->Symbol.c_str(),sizeof(obj2.Symbol));
			//obj2.Symbol=it2->Symbol;
			obj2.ExpiryDate=it2->ExpiryDate;
			obj2.StrikePrice=it2->StrikePrice;
			strncpy(obj2.OptionType,it2->OptionType.c_str(),sizeof(obj2.OptionType));
			//obj2.OptionType=it2->OptionType;
		//	obj2.DisclosedVolume=it2->BoardLotQuantity;
			obj2.Volume=it2->BoardLotQuantity;
			}
        }


                MS_OE_REQUEST_TR obj;

				obj.TransactionCode =ntohs((short)20000);
				obj.ReasonCode =ntohs((short)0);
				obj.BookType = ntohs((short)1);
				obj.GoodTillDate =ntohl(0);
/*
                obj.Oflag.AON=0;
                obj.Oflag.IOC=0;
                obj.Oflag.GTC=0;
                obj.Oflag.DAY=1;
                obj.Oflag.MIT=0;
                obj.Oflag.SL=0;
                obj.Oflag.MARKET=0;
                obj.Oflag.ATO=0;

                obj.Oflag.Reserved=0;
                obj.Oflag.Frozen=0;
                obj.Oflag.Modified=0;
                obj.Oflag.Traded=0;
                obj.Oflag.MatchedInd=0;
                obj.Oflag.MF=0;
*/
                obj.FlagIn=8;
                obj.FlagOut=0;

				obj.Reserved1 =2;
                obj.TokenNo = ntohl(Token);

                 strcpy(obj.InstrumentName,obj2.InstrumentName);
                 PadRight(obj.InstrumentName,sizeof(obj.InstrumentName)," ");
                 toUpper(obj.InstrumentName,sizeof(obj.InstrumentName));
                strcpy(obj.Symbol,obj2.Symbol);
                PadRight(obj.Symbol,sizeof(obj.Symbol)," ");
                toUpper(obj.Symbol,sizeof(obj.Symbol));
				obj.ExpiryDate =ntohl(obj2.ExpiryDate);
				obj.StrikePrice =ntohl(obj2.StrikePrice);
				strcpy(obj.OptionType,obj2.OptionType);
                PadRight(obj.OptionType,sizeof(obj.OptionType)," ");
                toUpper(obj.OptionType,sizeof(obj.OptionType));
                strcpy(obj.AccountNumber,"");//obj2.AccountNumber);
                PadRight(obj.AccountNumber,sizeof(obj.AccountNumber)," ");
                toUpper(obj.AccountNumber,sizeof(obj.AccountNumber));



				obj.Buy_SellIndicator =ntohs((short)BS);
				obj.DisclosedVolume = ntohl(Qty*obj2.Volume);
				obj.Volume =ntohl(Qty*obj2.Volume);
				obj.Price =ntohl(0);    //

                obj.Open_Close='O';

            //    printf("\nobj.Open_Close== %c",obj.Open_Close);

				//sprintf(&obj.Open_Close,"%c",'O');

				obj.UserId =ntohl(UserId);
				obj.BranchId =ntohs(BranchId);
				obj.TraderId =ntohl(UserId);

				strcpy(obj.BrokerId,"12468");
                PadRight(obj.BrokerId,sizeof(obj.BrokerId)," ");
                toUpper(obj.BrokerId,sizeof(obj.BrokerId));

                strcpy(obj.Settlor,"");
                PadRight(obj.Settlor,sizeof(obj.Settlor)," ");
                toUpper(obj.Settlor,sizeof(obj.Settlor));
				obj.Pro_ClientIndicator = ntohs(2);
				double dbl=ClientIdAuto;
				htond(dbl) ;
				obj.nnffield =dbl;

				obj.Length =ntohs(sizeof(MS_OE_REQUEST_TR));
			//	obj.SequenceNumber =ntohs(0);
				obj.MsgCount =ntohs(1);


                return obj;
		}



 void htond (double &x)
{
  int *Double_Overlay;
  int Holding_Buffer;
  Double_Overlay = (int *) &x;
  Holding_Buffer = Double_Overlay [0];
  Double_Overlay [0] = htonl (Double_Overlay [1]);
  Double_Overlay [1] = htonl (Holding_Buffer);
}



 MS_OM_REQUEST_TR ReturnModificationPack(int Token,BUYSELL BS)
		{


             //****we use dll for below line..................
		    //var _contract = CSV_Class.cimlist.Where (a => a.Token == Token).ToList ();
                MS_OM_REQUEST_TR obj2;
        for (vector<Contract_File>::iterator it2 = cimlist.begin(); it2 != cimlist.end(); it2++)
		{
			if (it2->Token == Token)
			{
			strncpy(obj2.InstrumentName,it2->InstrumentName.c_str(),sizeof(obj2.InstrumentName));
			//obj2.InstrumentName=it2->InstrumentName;
			strncpy(obj2.Symbol,it2->Symbol.c_str(),sizeof(obj2.Symbol));
			//obj2.Symbol=it2->Symbol;
			obj2.ExpiryDate=it2->ExpiryDate;
			obj2.StrikePrice=it2->StrikePrice;
			strncpy(obj2.OptionType,it2->OptionType.c_str(),sizeof(obj2.OptionType));
			//obj2.OptionType=it2->OptionType;
		//	obj2.DisclosedVolume=it2->BoardLotQuantity;
			obj2.Volume=it2->BoardLotQuantity;
			}
        }
           MS_OM_REQUEST_TR obj;

				//obj.TransactionCode =20000;
                obj.UserId =ntohl(UserId);
				obj.TokenNo = ntohl(Token);

                strcpy(obj.InstrumentName,obj2.InstrumentName);
                PadRight(obj.InstrumentName,sizeof(obj.InstrumentName)," ");
				toUpper(obj.InstrumentName,sizeof(obj.InstrumentName));



                strcpy(obj.Symbol,obj2.Symbol);
                PadRight(obj.Symbol,sizeof(obj.Symbol)," ");
                toUpper(obj.Symbol,sizeof(obj.Symbol));



                obj.ExpiryDate =ntohl(obj2.ExpiryDate);
                obj.StrikePrice = ntohl(obj2.StrikePrice);

                strcpy(obj.OptionType,obj2.OptionType);
                PadRight(obj.OptionType,sizeof(obj.OptionType)," ");
                toUpper(obj.OptionType,sizeof(obj.OptionType));

				obj.BookType = ntohs(1);
				obj.Buy_SellIndicator =ntohs((short) BS);
				obj.GoodTillDate =ntohl(0);

				obj.BranchId =ntohs(BranchId);
				obj.TraderId =ntohl(UserId);

                strcpy(obj.BrokerId,"12468");
                PadRight(obj.BrokerId,sizeof(obj.BrokerId)," ");
				toUpper(obj.BrokerId,sizeof(obj.BrokerId));



                obj.Open_Close = 'O';
                obj.Pro_ClientIndicator =ntohs(2);

                double dbl=ClientIdAuto;
				htond(dbl) ;
				obj.nnffield =dbl;
                obj.Modified_CancelledBy='T';
                /*
                obj.AON=0;
                obj.IOC=0;
                obj.GTC=0;
                obj.DAY=1;
                obj.MIT=0;
                obj.SL=0;
                obj.MARKET=0;
                obj.ATO=0;

                obj.Reserved=0;
                obj.Frozen=0;
                obj.Modified=0;
                obj.Traded=0;
                obj.MatchedInd=0;
                obj.MF=0;
*/
                //st_ord_flg_obj=Logic.Instance.OrderTypeFlag (OrderType.DAY),
				//st_ord_flg_obj = new ST_ORDER_FLAGS
				//{
					//STOrderFlagIn = Logic.Instance.GetBitsToByteValue(0, 0, 0, 1, 0, 0, 0, 0),
					//STOrderFlagOut = Logic.Instance.GetBitsToByteValue(0, 0, 0, 0, 0, 0, 0, 0),
				//}
                obj.FlagIn=8;
                obj.FlagOut=16;

                strcpy(obj.AccountNumber,"");
                PadRight(obj.AccountNumber,sizeof(obj.AccountNumber)," ");
                toUpper(obj.AccountNumber,sizeof(obj.AccountNumber));


                strcpy(obj.Settlor,"");
                PadRight(obj.Settlor,sizeof(obj.Settlor)," ");
                toUpper(obj.Settlor,sizeof(obj.Settlor));

				obj.Length =ntohs(sizeof(MS_OM_REQUEST_TR));
				obj.MsgCount =ntohs(1);
                //char buffer[sizeof(obj)];
                //memcpy(buffer,&obj,sizeof(obj));
                //return buffer;
            return obj;
		}



///end ReturnPack................................



public:
  char *HandleOnFOPairSubscription (char* buffer)
{



     strFOPAIR _FOpairObj;

	 memcpy(&_FOpairObj,buffer,sizeof(_FOpairObj));


map<int,TokenPartnerDetails>Primeleg;

if(Primeleg.find(_FOpairObj.TokenNear)==Primeleg.end())
{
Primeleg[_FOpairObj.TokenNear]=InitTokenDetails(_FOpairObj.TokenNear, _FOpairObj.TokenFar, _FOpairObj.PORTFOLIONAME);
}
if(Primeleg.find(_FOpairObj.TokenFar)==Primeleg.end())
{
Primeleg[_FOpairObj.TokenFar]=InitTokenDetails(_FOpairObj.TokenFar, _FOpairObj.TokenNear, _FOpairObj.PORTFOLIONAME);
}
			SymbolDictionary[_FOpairObj.TokenNear].FARTOKEN = _FOpairObj.TokenFar;
			SymbolDictionary[_FOpairObj.TokenNear].NEARTOKEN = _FOpairObj.TokenNear;
			SymbolDictionary[_FOpairObj.TokenNear].PFNUMBER = _FOpairObj.PORTFOLIONAME ;
			SymbolDictionary[_FOpairObj.TokenNear].BLQ= Primeleg[_FOpairObj.TokenFar].CF.BoardLotQuantity;

			SymbolDictionary[_FOpairObj.TokenFar].FARTOKEN = _FOpairObj.TokenFar;
			SymbolDictionary[_FOpairObj.TokenFar].NEARTOKEN = _FOpairObj.TokenNear ;
			SymbolDictionary[_FOpairObj.TokenFar].PFNUMBER = _FOpairObj.PORTFOLIONAME;
			SymbolDictionary[_FOpairObj.TokenFar].BLQ= Primeleg[_FOpairObj.TokenFar].CF.BoardLotQuantity;


//  Packet
	if (_NMPACK.find(_FOpairObj.TokenFar) ==_NMPACK.end())
	{
        memset(&_NMPACK[_FOpairObj.TokenFar],0,sizeof(MS_OE_REQUEST_TR));


		memcpy(&_NMPACK [_FOpairObj.TokenFar].NEARMONTHBUYMARKET,&ReturnNearPack(_FOpairObj.TokenNear, BUY, 1),sizeof(MS_OE_REQUEST_TR));
        memcpy(&_NMPACK [_FOpairObj.TokenFar].NEARMONTHSELLMARKET,&ReturnNearPack(_FOpairObj.TokenNear, SELL, 1),sizeof(MS_OE_REQUEST_TR));


		memcpy(&_NMPACK [_FOpairObj.TokenFar].FARMONTHBUY,&ReturnNearPack(_FOpairObj.TokenFar, BUY, 1),sizeof(MS_OE_REQUEST_TR));
		memcpy(&_NMPACK [_FOpairObj.TokenFar].FARMONTHSELL,&ReturnNearPack(_FOpairObj.TokenFar, SELL, 1),sizeof(MS_OE_REQUEST_TR));


        memcpy(&_NMPACK [_FOpairObj.TokenFar].FARMONTHMODBUY,&ReturnModificationPack(_FOpairObj.TokenFar,BUY),sizeof(MS_OM_REQUEST_TR));
        memcpy(&_NMPACK [_FOpairObj.TokenFar].FARMONTHMODSELL,&ReturnModificationPack(_FOpairObj.TokenFar, SELL),sizeof(MS_OM_REQUEST_TR));


        memset(&_NMPACK[_FOpairObj.TokenNear],0,sizeof(MS_OE_REQUEST_TR));


	}
// SubsCription
SubscribeToken(_FOpairObj.TokenNear);
SubscribeToken(_FOpairObj.TokenFar);

 //  BOARD_LOT_IN_TRBuy(_FOpairObj.TokenFar,ntohl(25),ntohl(1828795));
 cout << "Subscrition Done for PORTFOLIONAME " << _FOpairObj.PORTFOLIONAME<<" NEARTOKEN " << _FOpairObj.TokenNear<< " FARTOKEN " << _FOpairObj.TokenFar << endl;

//**************
/*

 MS_OE_REQUEST_TR objA=_NMPACK [_FOpairObj.TokenFar].NEARMONTHBUYMARKET;

 cout<<"NEARMONTHBUYMARKET -->>>size: "<<sizeof(buffer)<<"TokenNo "<<htonl(objA.TokenNo)<<" ExpiryDate "<<htonl(objA.ExpiryDate)
                <<"obj.AccountNumber-"<<objA.AccountNumber
                  <<"obj.InstrumentName-"<<objA.InstrumentName
                   <<"BUYSELL-"<<htons(objA.Buy_SellIndicator)
                    <<"Length-"<<htons(objA.Length)
                <<":"<<sizeof(objA.AccountNumber)
                <<"--> FlagIn: "<< objA.FlagIn<<" openClose: "<<objA.Open_Close
                <<" BuySell "<<htons(objA.Buy_SellIndicator)
                <<" Volume "<<htonl(objA.Volume)
                 <<" Price "<<htonl(objA.Price)
                <<" DisclosedVolume: "<<htonl(objA.DisclosedVolume)
                <<endl;

                MS_OM_REQUEST_TR obj=_NMPACK [_FOpairObj.TokenFar].FARMONTHMODBUY;
                cout<<"Struct -->>>size: "<<sizeof(buffer)<<"TokenNo "<<htonl(obj.TokenNo)<<" ExpiryDate "<<htonl(obj.ExpiryDate)
                <<"obj.AccountNumber-"<<obj.AccountNumber
                  <<"obj.InstrumentName-"<<obj.InstrumentName
                   <<"BUYSELL-"<<htons(obj.Buy_SellIndicator)
                    <<"Length-"<<htons(obj.Length)
                <<":"<<sizeof(obj.AccountNumber)
                <<"--> FlagIn: "<< obj.FlagIn<<" openClose: "<<obj.Open_Close

                <<" Volume "<<htonl(obj.Volume)
                     <<" Price "<<htonl(obj.Price)
                <<" DisclosedVolume: "<<htonl(obj.DisclosedVolume)
                <<endl;



                MS_OM_REQUEST_TR obj2=_NMPACK [_FOpairObj.TokenFar].FARMONTHMODSELL;
                cout<<"FARMONTHMODBUY -->>>size: "<<sizeof(buffer)<<"TokenNo "<<htonl(obj2.TokenNo)<<" ExpiryDate "<<htonl(obj2.ExpiryDate)
                <<"AccountNumber-"<<obj2.AccountNumber
                  <<".InstrumentName-"<<obj2.InstrumentName
                   <<"BUYSELL-"<<htons(obj2.Buy_SellIndicator)
                    <<"Length-"<<htons(obj2.Length)
                <<":"<<sizeof(obj2.AccountNumber)
                <<"--> FlagIn: "<< obj2.FlagIn<<" openClose: "<<obj2.Open_Close
 <<" BuySell "<<htons(obj2.Buy_SellIndicator)
                <<" Volume "<<htonl(obj2.Volume)
                 <<" Price "<<htonl(obj2.Price)
                <<" DisclosedVolume: "<<htonl(obj2.DisclosedVolume)
                <<endl;


*/

//*****************


}

int count;

 void HandleOnFOPairUnSubscription (char* buffer)
		{

		 strFOPAIR _FOpairObj;
	 	 	 memcpy(&_FOpairObj,buffer,sizeof(_FOpairObj));

	 	 	 if(SymbolDictionary[_FOpairObj.TokenFar].IsSubscribe)
			{
			//_udpObj.Subscribe = _FOpairObj.TokenFar;
			SymbolDictionary[_FOpairObj.TokenFar].IsSubscribe=false;
			}

            if(SymbolDictionary[_FOpairObj.TokenNear].IsSubscribe)
			{
			//_udpObj.Subscribe = _FOpairObj.TokenFar;
			SymbolDictionary[_FOpairObj.TokenNear].IsSubscribe=false;
			}


            UnSubscribeToken(_FOpairObj.TokenNear);
            UnSubscribeToken(_FOpairObj.TokenFar);
	 	 	 //_udpObj.UnSubscribe = _FOpairObj.TokenNear;
	 	 	 //_udpObj.UnSubscribe = _FOpairObj.TokenFar;


		/*

		//	var val = _OrderDetails [_FOpairObj.TokenFar].Values;
			try {
				if (_OrderDetails [_FOpairObj.TokenFar] ['B'].orderstat == (int)OrderStatus.OPEN || _OrderDetails [_FOpairObj.TokenFar] ['B'].orderstat == (int)OrderStatus.REPLACED || _OrderDetails [_FOpairObj.TokenFar] ['B'].orderstat == (int)OrderStatus.PENDING) {
					ORDER_CANCEL_IN_TR (_OrderDetails [_FOpairObj.TokenFar] ['B'].OrderNumber, _FOpairObj.TokenFar, BUYSELL.BUY);
					Console.WriteLine ("Cancelation Send Order No: " + _OrderDetails [_FOpairObj.TokenFar] ['B'].OrderNumber);
				}
				if (_OrderDetails [_FOpairObj.TokenFar] ['S'].orderstat == (int)OrderStatus.OPEN || _OrderDetails [_FOpairObj.TokenFar] ['S'].orderstat == (int)OrderStatus.REPLACED || _OrderDetails [_FOpairObj.TokenFar] ['S'].orderstat == (int)OrderStatus.PENDING) {
					ORDER_CANCEL_IN_TR (_OrderDetails [_FOpairObj.TokenFar] ['S'].OrderNumber, _FOpairObj.TokenFar, BUYSELL.SELL);

					Console.WriteLine ("Cancelation Send Order No: " + _OrderDetails [_FOpairObj.TokenFar] ['S'].OrderNumber);
				}
			} catch (Exception error) {
				Console.WriteLine ("Order Cancel Error on Un_SubsCribe   ------ " + error.StackTrace);
			}
*/
    cout << "FoPairUnsubscription is completed for PORTFOLIONAME " << _FOpairObj.PORTFOLIONAME<<" NEARTOKEN " << _FOpairObj.TokenNear<< " FARTOKEN " << _FOpairObj.TokenFar << endl;

		}


void HandleOnFOPairDiff (char* buffer)
	{
			struct FOPAIRDIFF _INpairDiff;
				memcpy(&_INpairDiff,buffer,sizeof(_INpairDiff));
			_FOPAIRDIFF [_INpairDiff.PORTFOLIONAME] = _INpairDiff;

			if(!SymbolDictionary[_INpairDiff.TokenFar].IsSubscribe)
			{
			//_udpObj.Subscribe = _FOpairObj.TokenFar;
			SymbolDictionary[_INpairDiff.TokenFar].IsSubscribe=true;
			}

            if(!SymbolDictionary[_INpairDiff.TokenNear].IsSubscribe)
			{
			//_udpObj.Subscribe = _FOpairObj.TokenFar;
			SymbolDictionary[_INpairDiff.TokenNear].IsSubscribe=true;
			}

			cout<<"Pairdiff Recieved...Far "<<_INpairDiff.TokenFar<<" Near "<<_INpairDiff.TokenNear<<" PFNUMBER "<<SymbolDictionary[_INpairDiff.TokenNear].PFNUMBER<<" BFSNDIFF "<<_INpairDiff.BFSNDIFF<<" BNSFDIFF "<<_INpairDiff.BNSFDIFF<<" BNSFMNQ "<<_INpairDiff.BNSFMNQ<<" BFSNMNQ "<<_INpairDiff.BFSNMNQ<<" BNSFMXQ "<<_INpairDiff.BNSFMXQ<<" BFSNMXQ "<<_INpairDiff.BFSNMXQ<<" TickCount "<<_INpairDiff.TickCount<<endl;
		}


void OnDataArrived(FinalPrice* _fp)
{
//cout<<"Ondatarrived"<<endl;
    _Datadict[_fp->Token]=*_fp;
	int NearMonth;
	int FarMonth;
	int PFNumber;
	int BLQ;
	NearMonth=SymbolDictionary[_fp->Token].NEARTOKEN;
	FarMonth= SymbolDictionary[_fp->Token].FARTOKEN;
	FinalPrice NearFP = _Datadict[NearMonth];
	FinalPrice FarFP = _Datadict[FarMonth];
	if(NearFP.Token <=0 || FarFP.Token<=0)
		return;
	PFNumber = SymbolDictionary[_fp->Token].PFNUMBER;
	BLQ = SymbolDictionary[_fp->Token].BLQ;
	int _BNSFMNQ = 0;
	int _BFSNMNQ = 0;
	int _BNSFMXQ = 0;
	int _BFSNMXQ = 0;
	int BFSNDIFF = 0;
	int BNSFDIFF = 0;

	_BNSFMNQ = _FOPAIRDIFF [PFNumber].BNSFMNQ;
	_BFSNMNQ = _FOPAIRDIFF [PFNumber].BFSNMNQ;
	_BNSFMXQ = _FOPAIRDIFF [PFNumber].BNSFMXQ;
	_BFSNMXQ = _FOPAIRDIFF [PFNumber].BFSNMXQ;

	BFSNDIFF = (int)_FOPAIRDIFF [PFNumber].BFSNDIFF;
	BNSFDIFF = (int)_FOPAIRDIFF [PFNumber].BNSFDIFF;

	int dFarBestBuyRate = _Datadict[FarMonth].MAXBID ;
	int dNearBestBuyRate = _Datadict[ NearMonth].MAXBID;
	int dFarBestSellRate = _Datadict[ FarMonth].MINASK;
	int dNearBestSellRate = _Datadict[NearMonth].MINASK;

  //cout<<"_Datadict[FarMonth].MAXBID: "<<dFarBestBuyRate<<" _Datadict[ NearMonth].MAXBID: "<<dNearBestBuyRate<<" _Datadict[ FarMonth].MINASK: "<<dFarBestSellRate<<"_Datadict[NearMonth].MINASK: "<<dNearBestSellRate<<endl;

//	=======================================================BuyNear SellFar============================

	int dAsksDifference = dFarBestSellRate - dNearBestSellRate;

//cout<<"dAsksDifference: "<<dAsksDifference<<" dFarBestSellRate: "<<dFarBestSellRate<<" dNearBestSellRate: "<<dNearBestSellRate<<endl;

	OrderDetails OrdDetailSell=_OrderDetailsSell[FarMonth];

	if((OrdDetailSell.orderstat == (OrderStatus)TRADE || OrdDetailSell.orderstat == (OrderStatus)CANCEL ||
						OrdDetailSell.orderstat == (OrderStatus)REJECTED || OrdDetailSell.orderstat == (OrderStatus)NONE)
						&& BNSFDIFF != 0 && BNSFDIFF <= dAsksDifference && _BNSFMNQ > 0 && _BNSFMXQ > 0 && OrdDetailSell.TotalTraded < _BNSFMXQ && OrdDetailSell.TotalTraded >= 0)
						// dAsksDifference > dHitsDifference
				 {		//	 ( FAROPENSELLQTY ==0 && BNSFDIFF != 0 && dAsksDifference > dHitsDifference && _BNSFMNQ > 0 && _BNSFMXQ > 0 && FARTRADEDSELLQTY < _BNSFMXQ && FARTRADEDSELLQTY >= 0 )

						int dFarMonthSellRate = 0;

						if (BNSFDIFF < dAsksDifference) {
							dFarMonthSellRate = (dFarBestSellRate) - 5;

						} else if (BNSFDIFF == dAsksDifference) {
							dFarMonthSellRate = (dNearBestSellRate) + (BNSFDIFF);
						}


						if (dFarMonthSellRate > 0) {

							OrdDetailSell.orderstat = (OrderStatus)PENDING;
						//	OrdDetailSell.orderstat = (OrderStatus)OPEN;
							OrdDetailSell.Token = FarMonth;
							OrdDetailSell.OrderNumber = -1;
							OrdDetailSell.ReplaceCount = 1;

							OrdDetailSell.OrderType = (_orderType)LIMIT;
							OrdDetailSell.Price = dFarMonthSellRate;
							OrdDetailSell.Qty = _FOPAIRDIFF [PFNumber].BNSFMNQ;
							OrdDetailSell.TotalTraded += 1;
							OrdDetailSell.side = (BUYSELL)SELL;

							_OrderDetailsSell[FarMonth] = OrdDetailSell;

							BOARD_LOT_IN_TRSell (
								FarMonth,
							//	ntohl(OrdDetailSell.Qty * BLQ),
								ntohl(OrdDetailSell.Price)
							);




						}



					}

	 else if(dAsksDifference >= BNSFDIFF && (OrdDetailSell.orderstat == (OrderStatus)OPEN || OrdDetailSell.orderstat == (OrderStatus)REPLACED))

					 {
				//	 cout<<"step 1 State:"<<dAsksDifference <<" : "<< BNSFDIFF<<" OrderStatus "<<OrdDetailSell.orderstat<<endl;
							if (dAsksDifference > BNSFDIFF) {
								int dQuoteRate = (dFarBestSellRate) - 5;
								int Prevprice = 0;
								Prevprice = OrdDetailSell.Price;
								OrdDetailSell.Price = dQuoteRate;
								if (Prevprice != dFarBestSellRate && Prevprice != dQuoteRate) {
									OrdDetailSell.orderstat = (OrderStatus)PENDING;
                                //    OrdDetailSell.orderstat = (OrderStatus)REPLACED;

									ORDER_MOD_IN_TR (
									                FarMonth,
									            //    ntohl( OrdDetailSell.Qty * BLQ),
									                ntohl(dQuoteRate),(BUYSELL)SELL
									);


									OrdDetailSell.ReplaceCount += 1;

									_OrderDetailsSell[FarMonth] = OrdDetailSell;

                      //cout<<"step 2 "<<endl;

								}
							} else if (dAsksDifference == BNSFDIFF) {

								int dQuoteRateM = (dNearBestSellRate) + BNSFDIFF;
								int Prevprice = 0;
								Prevprice = OrdDetailSell.Price;
								OrdDetailSell.Price = dQuoteRateM;
						//		  cout<<"step 3 "<<Prevprice <<" "<< dQuoteRateM<<endl;
								if (Prevprice != dQuoteRateM) {

									OrdDetailSell.orderstat = (OrderStatus)PENDING;
                                //	OrdDetailSell.orderstat = (OrderStatus)REPLACED;
									ORDER_MOD_IN_TR (
									                OrdDetailSell.Token,
									          //      ntohl( OrdDetailSell.Qty *BLQ),
									                		ntohl(dQuoteRateM),(BUYSELL)SELL
									);


									OrdDetailSell.ReplaceCount += 1;

									_OrderDetailsSell[FarMonth] = OrdDetailSell;

								}
							} else {
								OrdDetailSell.orderstat = (OrderStatus)PENDING;
								ORDER_CANCEL_IN_TR ( OrdDetailSell.Token, (BUYSELL)SELL);
								//	OrdDetailSell.orderstat = (OrderStatus)CANCEL;
								OrdDetailSell.ReplaceCount += 1;
								OrdDetailSell.Price = 0;
								//	OrdDetailSell.TotalTraded-=1;

								_OrderDetailsSell[FarMonth] = OrdDetailSell;
						//		 cout<<"step 4 "<<endl;
							}


						} else if ((OrdDetailSell.orderstat == (OrderStatus)OPEN || OrdDetailSell.orderstat == (OrderStatus)REPLACED) && dAsksDifference < BNSFDIFF) { //Double check to cancel

							OrdDetailSell.orderstat = (OrderStatus)PENDING;
							ORDER_CANCEL_IN_TR ( OrdDetailSell.Token, (BUYSELL)SELL);
							//	OrdDetailSell.orderstat = (OrderStatus)CANCEL;
							OrdDetailSell.ReplaceCount += 1;
							OrdDetailSell.Price = 0;
							//	OrdDetailSell.TotalTraded-=1;

							_OrderDetailsSell[FarMonth] = OrdDetailSell;
                    //    cout<<"step 5 "<<endl;


						}



	//	=======================================================BuyFar SellNear============================

		//=================================================================BUY FAR SELL NEAR SECTION STARTS HERE =======================================


			int dBidsDifference = dFarBestBuyRate - dNearBestBuyRate;
			OrderDetails OrdDetailBuy =_OrderDetailsBuy[FarMonth] ;


			if
			((OrdDetailBuy.orderstat == (OrderStatus)TRADE || OrdDetailBuy.orderstat == (OrderStatus)CANCEL ||
				OrdDetailBuy.orderstat == (OrderStatus)REJECTED || OrdDetailBuy.orderstat == (OrderStatus)NONE)
				&& BFSNDIFF != 0 && BFSNDIFF >= dBidsDifference && _BFSNMNQ > 0 && _BFSNMXQ > 0 && OrdDetailBuy.TotalTraded < _BFSNMXQ && OrdDetailBuy.TotalTraded >= 0)

				//dBidsDifference < dHitsDifference
{		//	 (FAROPENBUYQTY ==0   && BFSNDIFF != 0 && dBidsDifference < dHitsDifference && _BFSNMNQ > 0 && _BFSNMXQ > 0 && FARTRADEDBUYQTY < _BFSNMXQ && FARTRADEDBUYQTY >= 0)

				int dFarMonthBuyRate = 0;

				if (BFSNDIFF > dBidsDifference) {
					dFarMonthBuyRate = (dFarBestBuyRate) + 5;

				} else if (BFSNDIFF == dBidsDifference) {
					dFarMonthBuyRate = (dNearBestBuyRate) + (BFSNDIFF);
					}

				if (dFarMonthBuyRate > 0) {

					OrdDetailBuy.orderstat = (OrderStatus)PENDING;
					//	OrdDetailBuy.orderstat = (OrderStatus)OPEN;
					OrdDetailBuy.Token = FarMonth;
					OrdDetailBuy.OrderNumber = -1;
					OrdDetailBuy.ReplaceCount = 1;
					OrdDetailBuy.OrderType = (_orderType)LIMIT;
					OrdDetailBuy.Price = dFarMonthBuyRate;
					OrdDetailBuy.Qty = _FOPAIRDIFF [PFNumber].BFSNMNQ;
					OrdDetailBuy.TotalTraded += 1;
					OrdDetailBuy.side = (BUYSELL)BUY;

				  _OrderDetailsBuy[FarMonth] = OrdDetailBuy;


					BOARD_LOT_IN_TRBuy (
						FarMonth,
					//	ntohl(OrdDetailBuy.Qty *BLQ),
						ntohl(OrdDetailBuy.Price)
					);

					return;

				}


			} else if
				(dBidsDifference <= BFSNDIFF && (OrdDetailBuy.orderstat == (OrderStatus)OPEN || OrdDetailBuy.orderstat == (OrderStatus)REPLACED))

{

				if (dBidsDifference < BFSNDIFF) {


					int dQuoteRate = (dFarBestBuyRate) + 5;
					int Prevprice = 0;
					Prevprice = OrdDetailBuy.Price;
					OrdDetailBuy.Price = dQuoteRate;

					if (Prevprice != dFarBestBuyRate && Prevprice != dQuoteRate) {

						OrdDetailBuy.orderstat = (OrderStatus)PENDING;


						ORDER_MOD_IN_TR (
						                OrdDetailBuy.Token,
						         //       ntohl(OrdDetailBuy.Qty *BLQ),
						                		ntohl(dQuoteRate),(BUYSELL)BUY
						);

						//	OrdDetailBuy.orderstat = (OrderStatus)REPLACED;
						OrdDetailBuy.ReplaceCount += 1;

						_OrderDetailsBuy[FarMonth] = OrdDetailBuy;

					}

				} else if (dBidsDifference == BFSNDIFF) {

					int dQuoteRateM = (dNearBestBuyRate) + BFSNDIFF;
					int Prevprice = 0;
					Prevprice = OrdDetailBuy.Price;
					OrdDetailBuy.Price = dQuoteRateM;
					if (Prevprice != dQuoteRateM) {

						OrdDetailBuy.orderstat = (OrderStatus)PENDING;
						ORDER_MOD_IN_TR (
						                OrdDetailBuy.Token,
						           //     ntohl( OrdDetailBuy.Qty *BLQ),
						                		ntohl( dQuoteRateM),(BUYSELL)BUY

						);

						//	OrdDetailBuy.orderstat = (OrderStatus)REPLACED;
						OrdDetailBuy.ReplaceCount += 1;

						_OrderDetailsBuy [FarMonth]  = OrdDetailBuy;

					}
				} else {
					OrdDetailBuy.orderstat = (OrderStatus)PENDING;
					ORDER_CANCEL_IN_TR ( OrdDetailBuy.Token, (BUYSELL)BUY);

					//	OrdDetailBuy.orderstat = (OrderStatus)CANCEL;
					OrdDetailBuy.ReplaceCount += 1;
					OrdDetailBuy.Price = 0;
					//	OrdDetailBuy.TotalTraded-=1;

					_OrderDetailsBuy [FarMonth] = OrdDetailBuy;


				}

			} else if((OrdDetailBuy.orderstat == (OrderStatus)OPEN || OrdDetailBuy.orderstat == (OrderStatus)REPLACED) &&
				dBidsDifference > BFSNDIFF) {

				OrdDetailBuy.orderstat = (OrderStatus)PENDING;

				ORDER_CANCEL_IN_TR (OrdDetailBuy.Token, (BUYSELL)BUY);
				//	OrdDetailBuy.orderstat = (OrderStatus)CANCEL;
				OrdDetailBuy.ReplaceCount += 1;
				OrdDetailBuy.Price = 0;
				//	OrdDetailBuy.TotalTraded-=1;

				_OrderDetailsBuy [FarMonth] = OrdDetailBuy;


			}
//=================================================================BUY FAR SELL NEAR SECTION ENDS HERE =======================================
}


 void BOARD_LOT_IN_TRBuy(int FarTokenNo, int price)  //-- 20000
		{// MS_OE_REQUEST_TR 110+26


		  MS_OE_REQUEST_TR obj;
cout<<"BOARD_LOT_IN_TRBuy Step 1 \n";
                memset(&obj,0,136);
cout<<"BOARD_LOT_IN_TRBuy Step 2 \n";
            cout<<"Buy: "<<FarTokenNo<<" price "<<htonl(price)<<" size "<<sizeof (_NMPACK [FarTokenNo].FARMONTHBUY) <<endl;

cout<<"BOARD_LOT_IN_TRBuy Step 3 \n";


                   obj=_NMPACK [FarTokenNo].FARMONTHBUY;
	 	cout<<"BOARD_LOT_IN_TRBuy Step 4 \n";
	 			//	obj.DisclosedVolume=obj.Volume=volume;
	 				obj.Price=price;
	 	cout<<"BOARD_LOT_IN_TRBuy Step 5 \n";
	 				ProcessToEnqueue((char*)&obj,136);
cout<<"BOARD_LOT_IN_TRBuy Step 6 \n";
		}


 void BOARD_LOT_IN_TRSell(int FarTokenNo, int price)  //-- 20000
		{// MS_OE_REQUEST_TR 110+26
//MS_OE_REQUEST_TR obj_Ms_Oe_req_tr;
 MS_OE_REQUEST_TR obj;
cout<<"BOARD_LOT_IN_TRSell Step 1 \n";
            memset(&obj,0,136);
cout<<"BOARD_LOT_IN_TRSell Step 2 \n";
cout<<"Sell: "<<FarTokenNo<<" price "<<htonl(price)<<" size "<<sizeof (_NMPACK [FarTokenNo].FARMONTHSELL) <<endl;
cout<<"BOARD_LOT_IN_TRSell Step 3 \n";
                    obj=_NMPACK [FarTokenNo].FARMONTHSELL;
cout<<"BOARD_LOT_IN_TRSell Step 4 \n";
	 			//	obj.DisclosedVolume=obj.Volume=volume;
cout<<"BOARD_LOT_IN_TRSell Step 5 \n";
	 				obj.Price=price;
	 				ProcessToEnqueue((char*)&obj,136);
cout<<"BOARD_LOT_IN_TRSell Step 6 \n";
		}


 void ORDER_MOD_IN_TR(int TokenNo, int price,BUYSELL buySell)// 20040
{		//MS_OM_REQUEST_TR 138+26=164



                    MS_OM_REQUEST_TR obj;
                    memset(&obj,0,164);
  	 				switch ((short)buySell) {
	 				case 1:
	 					obj=_NMPACK [TokenNo].FARMONTHMODBUY;

	 					break;
	 				case 2:
	 					obj=_NMPACK [TokenNo].FARMONTHMODSELL;

	 					break;
	 				}
	 				char TransCodeBytes[0];

	 				obj.TransactionCode=ModificationCode;
	 			//	obj.DisclosedVolume=obj.Volume=volume;
	 				obj.Price=price;

                    ProcessToEnqueue((char*)&obj,164);

		}


 void ORDER_CANCEL_IN_TR(int TokenNo, BUYSELL buySell)  //-- 20070
		{
				//MS_OM_REQUEST_TR 138+26=164

                MS_OM_REQUEST_TR obj;
                memset(&obj,0,164);

  	 				switch ((short)buySell) {
	 				case 1:
	 					obj=_NMPACK [TokenNo].FARMONTHMODBUY;
	 					break;
	 				case 2:
	 					obj=_NMPACK [TokenNo].FARMONTHMODSELL;

	 					break;
	 				}
	 				char TransCodeBytes[0];
	 				obj.TransactionCode=CancelCode;

                    ProcessToEnqueue((char*)&obj,164);
		}

 //==========================================================   OUT



 void ORDER_CONFIRMATION_TR (char *buffer) //-- 20073
		{
			 MS_OE_RESPONSE_TR obj;//156
			  memset(&obj,0,156);
			   memcpy(&obj,buffer,156);


		short _BS = htons(obj.Buy_SellIndicator);
		int _TKN = htonl(obj.TokenNo);
		double _OrderNo =obj.OrderNumber ;
		int _price = htonl(obj.Price);
        int _Volume = htonl(obj.Volume);

		switch (_BS) {
		case  (BUYSELL)BUY:
			{
			 MS_OM_REQUEST_TR OMObj;
			 memset(&OMObj,0,164);
           OMObj=_NMPACK [_TKN].FARMONTHMODBUY;
            OMObj.OrderNumber=obj.OrderNumber;
            OMObj.DisclosedVolume =obj.DisclosedVolume ;
             OMObj.DisclosedVolumeRemaining =obj.DisclosedVolumeRemaining ;
              OMObj.TotalVolumeRemaining =obj.TotalVolumeRemaining ;
               OMObj.Volume =obj.Volume ;
                OMObj.VolumeFilledToday =obj.VolumeFilledToday ;
                 OMObj.Price =obj.Price ;
                  OMObj.EntryDateTime =obj.EntryDateTime ;
                   OMObj.LastModified =obj.LastModified ;
                    OMObj.filler =obj.filler ;

     _NMPACK [_TKN].FARMONTHMODBUY=OMObj;

       _OrderDetailsBuy[_TKN].orderstat = (OrderStatus)OPEN;
     	_OrderDetailsBuy[_TKN].OrderNumber = _OrderNo;
     		_OrderDetailsBuy[_TKN].Price = _price;
				break;
			}
		case  (BUYSELL)SELL:

			{
			MS_OM_REQUEST_TR OMObj;
			 memset(&OMObj,0,164);
			   OMObj=_NMPACK [_TKN].FARMONTHMODSELL;
            OMObj.OrderNumber=obj.OrderNumber;
            OMObj.DisclosedVolume =obj.DisclosedVolume ;
             OMObj.DisclosedVolumeRemaining =obj.DisclosedVolumeRemaining ;
              OMObj.TotalVolumeRemaining =obj.TotalVolumeRemaining ;
               OMObj.Volume =obj.Volume ;
                OMObj.VolumeFilledToday =obj.VolumeFilledToday ;
                 OMObj.Price =obj.Price ;
                  OMObj.EntryDateTime =obj.EntryDateTime ;
                   OMObj.LastModified =obj.LastModified ;
                    OMObj.filler =obj.filler ;

     _NMPACK [_TKN].FARMONTHMODSELL=OMObj;
     _OrderDetailsSell[_TKN].orderstat = (OrderStatus)OPEN;
     	_OrderDetailsSell[_TKN].OrderNumber = _OrderNo;
     		_OrderDetailsSell[_TKN].Price = _price;


     	break;
			}
		}

     //   ORDER_MOD_IN_TR(_TKN, 50,ntohl( _price+100),(BUYSELL)_BS);
	}


		 void ORDER_CXL_CONFIRMATION_TR (char *buffer) //-- 20075
	{

			 MS_OE_RESPONSE_TR obj;//156
			 memset(&obj,0,156);
			 memcpy(&obj,buffer,156);
        short _BS = htons(obj.Buy_SellIndicator);
		int _TKN = htonl(obj.TokenNo);
        switch(_BS)
		{
		case (BUYSELL)BUY:
		_OrderDetailsBuy[_TKN].orderstat = (OrderStatus)CANCEL;
		_OrderDetailsBuy[_TKN].TotalTraded -=1 ;

		break;
		case (BUYSELL)SELL:
		_OrderDetailsSell[_TKN].orderstat = (OrderStatus)CANCEL;
		_OrderDetailsSell[_TKN].TotalTraded -=1 ;
		break;

		}
	}


		 void ORDER_MOD_CONFIRMATION_TR (char *buffer) //-- 20074
		{

        MS_OE_RESPONSE_TR obj;//156
        memset(&obj,0,156);
		memcpy(&obj,buffer,156);
		short _BS = htons(obj.Buy_SellIndicator);
		int _TKN = htonl(obj.TokenNo);
		double _OrderNo =obj.OrderNumber ;
		int _price = htonl(obj.Price);

		switch (_BS) {
		case  (BUYSELL)BUY:
			{

			MS_OM_REQUEST_TR OMObj;
			 memset(&OMObj,0,164);
            OMObj=_NMPACK [_TKN].FARMONTHMODBUY;
            OMObj.OrderNumber=obj.OrderNumber;
            OMObj.DisclosedVolume =obj.DisclosedVolume ;
             OMObj.DisclosedVolumeRemaining =obj.DisclosedVolumeRemaining ;
              OMObj.TotalVolumeRemaining =obj.TotalVolumeRemaining ;
               OMObj.Volume =obj.Volume ;
                OMObj.VolumeFilledToday =obj.VolumeFilledToday ;
                 OMObj.Price =obj.Price ;
                  OMObj.EntryDateTime =obj.EntryDateTime ;
                   OMObj.LastModified =obj.LastModified ;
                    OMObj.filler =obj.filler ;

            _NMPACK [_TKN].FARMONTHMODBUY=OMObj;

            _OrderDetailsBuy[_TKN].orderstat = (OrderStatus)REPLACED;
     		_OrderDetailsBuy[_TKN].Price = _price;
            break;
			}
		case  (BUYSELL)SELL:

			{
			MS_OM_REQUEST_TR OMObj;
			 memset(&OMObj,0,164);
		    OMObj=_NMPACK [_TKN].FARMONTHMODSELL;
            OMObj.OrderNumber=obj.OrderNumber;
            OMObj.DisclosedVolume =obj.DisclosedVolume ;
             OMObj.DisclosedVolumeRemaining =obj.DisclosedVolumeRemaining ;
              OMObj.TotalVolumeRemaining =obj.TotalVolumeRemaining ;
               OMObj.Volume =obj.Volume ;
                OMObj.VolumeFilledToday =obj.VolumeFilledToday ;
                 OMObj.Price =obj.Price ;
                  OMObj.EntryDateTime =obj.EntryDateTime ;
                   OMObj.LastModified =obj.LastModified ;
                    OMObj.filler =obj.filler ;

                _NMPACK [_TKN].FARMONTHMODSELL=OMObj;
                _OrderDetailsSell[_TKN].orderstat = (OrderStatus)REPLACED;
                _OrderDetailsSell[_TKN].Price = _price;

              //  cout<<_TKN<<" bs "<<_BS<<" price "<<_price<<endl;
                break;
			}
		}


	//	ORDER_CANCEL_IN_TR(_TKN,(BUYSELL)_BS);

	}

		 void TRADE_CONFIRMATION_TR (char *buffer) //-- 20222
		{
          MS_TRADE_CONFIRM_TR obj_Trade;
          memset(&obj_Trade,0,153);
            memcpy(&obj_Trade,buffer,153);
				int _TKN =htonl(obj_Trade.Token);
				short _BS = htons(obj_Trade.Buy_SellIndicator);
          if(SymbolDictionary[_TKN].FARTOKEN==_TKN)
          {

                FinalPrice _FPNear1= _Datadict[SymbolDictionary[_TKN].NEARTOKEN];


			switch (_BS)
			{
				case (BUYSELL)BUY:
				{
                    MS_OE_REQUEST_TR obj_New;
                    memset(&obj_New,0,136);
                    obj_New=_NMPACK [_TKN].NEARMONTHSELLMARKET;
	 				ProcessToEnqueue((char*)&obj_New,136);
                    _OrderDetailsBuy[_TKN].orderstat = (OrderStatus)TRADE;
                }

				break;
				case (BUYSELL)SELL:
				{
                    MS_OE_REQUEST_TR obj_New;
                    memset(&obj_New,0,136);
                    obj_New=_NMPACK [_TKN].NEARMONTHBUYMARKET;
                    ProcessToEnqueue((char*)&obj_New,136);
                    _OrderDetailsSell[_TKN].orderstat = (OrderStatus)TRADE;
                }
				break;
			}
			//  cout<<"Trade _TKN: "<<_TKN<<" _BS: "<<_BS<<endl;
			 cout<<"Trade Far  _TKN: "<<_TKN<<" _BS: "<<_BS<<endl;
			}
			 else
			  cout<<"Trade Near  _TKN: "<<_TKN<<" _BS: "<<_BS<<endl;


		}


		 void ORDER_CXL_REJ_OUT (char *buffer) //-- 2072
		{//MS_OE_REQUEST 240

            MS_OE_REQUEST obj;
			memset(&obj,0,240);
            memcpy(&obj,buffer,240);

								 	short _BS =htons(obj.Buy_SellIndicator);
							int _TKN =htonl(obj.TokenNo);
							short _Error = htons(obj.ErrorCode);


							switch(_BS)
							{
							case (BUYSELL)BUY:

							if (_Error == 16273)
							_OrderDetailsBuy[_TKN].orderstat = (OrderStatus)CANCEL;
							else if(_OrderDetailsBuy[_TKN].orderstat != (OrderStatus)TRADE)
							_OrderDetailsBuy[_TKN].orderstat = (OrderStatus)REPLACED;
							break;
							case (BUYSELL)SELL:
							if (_Error == 16273)
							_OrderDetailsSell[_TKN].orderstat = (OrderStatus)CANCEL;
							else if(_OrderDetailsSell[_TKN].orderstat != (OrderStatus)TRADE)
							_OrderDetailsSell[_TKN].orderstat = (OrderStatus)REPLACED;
							break;
							}
                }


		 void ORDER_MOD_REJ_OUT (char *buffer) //-- 2042
            {//MS_OE_REQUEST 240

             MS_OE_REQUEST obj;
             memset(&obj,0,240);
			 memcpy(&obj,buffer,240);

                short _BS =htons(obj.Buy_SellIndicator);
				int _TKN =htonl(obj.TokenNo);
				short _Error = htons(obj.ErrorCode);

				switch(_BS)
				{
				case (BUYSELL)BUY:

				if (_Error == 16273)
				_OrderDetailsBuy[_TKN].orderstat = (OrderStatus)CANCEL;
				else if(_OrderDetailsBuy[_TKN].orderstat != (OrderStatus)TRADE)
				_OrderDetailsBuy[_TKN].orderstat = (OrderStatus)REPLACED;
				break;
				case (BUYSELL)SELL:
				if (_Error == 16273)
				_OrderDetailsSell[_TKN].orderstat = (OrderStatus)CANCEL;
				else if(_OrderDetailsSell[_TKN].orderstat != (OrderStatus)TRADE)
				_OrderDetailsSell[_TKN].orderstat = (OrderStatus)REPLACED;
				break;

				}

	}

    void ORDER_ERROR_OUT (char *buffer) //-- 2231
		{
            //MS_OE_REQUEST 240
            cout<<"ORDER_ERROR_OUT Step 1 \n";
            cout<<"ORDER_ERROR_OUT Step 2 \n";
            			MS_OE_REQUEST obj;
            			 memset(&obj,0,240);
			 	 memcpy(&obj,buffer,240);
            cout<<"ORDER_ERROR_OUT Step 3 \n";
        short _BS =htons(obj.Buy_SellIndicator);
		int _TKN =htonl(obj.TokenNo);
            cout<<"ORDER_ERROR_OUT Step 4 \n";
		switch(_BS)
		{
		case (BUYSELL)BUY:
		_OrderDetailsBuy[_TKN].orderstat = (OrderStatus)REJECTED;
		_OrderDetailsBuy[_TKN].TotalTraded -=1 ;
     //   cout<<"ORDER_ERROR_OUT BUY\n";
		break;
		case (BUYSELL)SELL:
		_OrderDetailsSell[_TKN].orderstat = (OrderStatus)REJECTED;
		_OrderDetailsSell[_TKN].TotalTraded -=1 ;
	//	cout<<"ORDER_ERROR_OUT SELL\n";
		break;

		}
		            cout<<"ORDER_ERROR_OUT Step 5 \n";
		}



  int Datasock;// = nn_socket(AF_SP, NN_SUB);
void SubscribeToken (int _token)
{
nn_setsockopt(Datasock, NN_SUB, NN_SUB_SUBSCRIBE,&_token , 4);
}
void UnSubscribeToken (int _token)
{
nn_setsockopt(Datasock, NN_SUB, NN_SUB_UNSUBSCRIBE,&_token , 4);
}

void Datasubscriber (void *data)
//void Datasubscriber ()
{
    const char* addr = "tcp://192.168.168.36:7979";
 // const char* addr = "tcp://192.168.168.36:2911";
 // const char* addr = "inproc://DataSubPub";
cout << "Datasubscriber Start: "<<addr<<"  ClientIdAuto: "<<ClientIdAuto<<endl;

//cout << "Datasubscriber Step:  1 "<<endl;
Datasock = nn_socket(AF_SP, NN_SUB);
// cout << "Datasubscriber Step:  2 "<<endl;
  assert(Datasock >= 0);
  //  *msg1=123;
  int msg =111;
  assert(nn_setsockopt(Datasock, NN_SUB, NN_SUB_SUBSCRIBE,&msg , sizeof(msg)) >= 0);

/*
  msg =44381;
  assert(nn_setsockopt(Datasock, NN_SUB, NN_SUB_SUBSCRIBE,&msg , sizeof(msg)) >= 0);
  msg =44370;
  assert(nn_setsockopt(Datasock, NN_SUB, NN_SUB_SUBSCRIBE,&msg , sizeof(msg)) >= 0);
   msg =44293;
 assert(nn_setsockopt(Datasock, NN_SUB, NN_SUB_SUBSCRIBE,&msg , sizeof(msg)) >= 0);
   msg =44932;
  assert(nn_setsockopt(Datasock, NN_SUB, NN_SUB_SUBSCRIBE,&msg , sizeof(msg)) >= 0);
 */
  assert(nn_connect(Datasock, addr) >= 0);
//std::mutex lock;



  FinalPrice* buf;


  buf =(FinalPrice *) std::malloc(sizeof(FinalPrice));


  int fpSize= sizeof(FinalPrice);


  while (!IsExit) {

    int bytes = nn_recv(Datasock, buf,fpSize, 0);



    if(bytes > 0)
    {

       /* _Datadict[buf->Token]=*buf;
        printf("\n");
        printf("received: %d %d %d %d byte %d size %d \n", buf->Token,buf->MAXBID , buf->MINASK , buf->LTP,bytes, fpSize);
        printf("received Dict : %d %d %d %d %d \n", _Datadict[buf->Token].Token,_Datadict[buf->Token].MAXBID , _Datadict[buf->Token].MINASK , _Datadict[buf->Token].LTP);
        printf("\n");
        */
     //   cout<< "Recv Token : "<< buf->Token<<endl;
        OnDataArrived(buf);

    }

    /*nn_freemsg(&buf);*/
    //memset(&buf, 0, 200);
  }
 cout << "Datasubscriber End" << endl;
  free(buf);
 //   pthread_mutex_destroy(&mutex2);
  }

long long concat(long long x, long long y)
{
    long long temp = y;
    while (y != 0) {
        x *= 10;
        y /= 10;
    }
    return x + temp;
}

/*
struct getTrans
{
short getTransCode;
};
*/

 void Eventsubscriber (void *data)
    {

// const char* addr = "tcp://127.0.0.1:7071";
 const char* addr = "inproc://eventpubsub";

cout << "--Eventsubscriber Start: "<<addr<<"  ClientIdAuto: "<<ClientIdAuto<<endl;
 int* msg1;
//cout << "Eventsubscriber Step:  1 "<<endl;
  int sock = nn_socket(AF_SP, NN_SUB);
//  cout << "Eventsubscriber Step:  2 "<<endl;
  assert(sock >= 0);
  //  *msg1=123;
  long lng=concat((short)(MessageType)eORDER,ClientIdAuto);
   nn_setsockopt(sock, NN_SUB,NN_SUB_SUBSCRIBE,&lng , sizeof(lng));

  lng=concat((short)(MessageType)eFOPAIR,ClientIdAuto);

   nn_setsockopt(sock, NN_SUB,NN_SUB_SUBSCRIBE,&lng , sizeof(lng));

   lng=concat((short)(MessageType)eFOPAIRDIFF,ClientIdAuto);
   nn_setsockopt(sock, NN_SUB,NN_SUB_SUBSCRIBE,&lng , sizeof(lng));

   lng=concat((short)(MessageType)eFOPAIRUNSUB,ClientIdAuto);
   nn_setsockopt(sock, NN_SUB,NN_SUB_SUBSCRIBE,&lng , sizeof(lng));


  assert(nn_connect(sock, addr) >= 0);
char* _buffer;
    _buffer =(char *)malloc(1024);


 while (!IsExit)
 {
        int size = nn_recv(sock, _buffer,1024, 0);
	 	  long suId;
       //     memcpy(&suId,_buffer,sizeof(suId));
       		suId=*(long*)_buffer;
            short MsgType =suId/1000000000000000;
	// 	 cout<< "->MsgType "<<MsgType<<" size: "<<size<<" suId "<<suId<<" MsgType "<<(char)MsgType<<" "<<MsgType<<endl;

	 	 char buffer[size-8];
	 	 memcpy(buffer,_buffer+8,size-8);
				switch ((MessageType)MsgType)//(MessageType)BitConverter.ToInt16(_IncomingData, 0))
								{

									case (MessageType)eFOPAIR:

									HandleOnFOPairSubscription(buffer);
										//	OnFOPairSubscription.Raise (OnFOPairSubscription, OnFOPairSubscription.CreateReadOnlyArgs (buffer));
											break;
									case (MessageType)eFOPAIRDIFF:
									HandleOnFOPairDiff(buffer);
										//	OnFOPairDiff.Raise (OnFOPairDiff, OnFOPairDiff.CreateReadOnlyArgs (buffer));
											break;
									case (MessageType)eFOPAIRUNSUB:
									HandleOnFOPairUnSubscription(buffer);
										//	OnFOPairUnSubscription.Raise (OnFOPairUnSubscription, OnFOPairUnSubscription.CreateReadOnlyArgs (buffer));
											break;
									case (MessageType)eORDER:
									//char tr[2];
										short TransCode;
										TransCode=*(short*)buffer;

									//	memcpy(&tr,buffer,2);
										//TransCode=atoi(tr);
									//	cout<<"TransCode: "<<htons(TransCode)<<endl;

										switch (htons(TransCode)) {

											case 20073:

											ORDER_CONFIRMATION_TR (buffer);
											break;

											case 20075:
											ORDER_CXL_CONFIRMATION_TR (buffer);
											break;

											case 20074:
											ORDER_MOD_CONFIRMATION_TR (buffer);
											break;

											case 20222:

											TRADE_CONFIRMATION_TR (buffer);

											break;

											case 2072:
											ORDER_CXL_REJ_OUT (buffer);
											break;

											case 2042:
											ORDER_MOD_REJ_OUT (buffer);
											break;

											case 2231:
											ORDER_ERROR_OUT (buffer);
											break;
										}
								break;
									default:
									break;
									 free (buffer);

								}
						}
						 cout << "Eventsubscriber End" << endl;
                free (_buffer);
		}





	void Dispose()
	{
	cout<<"Dispose Of class Called"<<endl;
	IsExit=true;
    cout<<"DisposeCPP End SuccessFully........."<<endl;
	}

    void test()
	{
		 char abc[]="Hello from Test";


        // do the work...

        if (ProcessToEnqueue)
        {
            // send progress update
            ProcessToEnqueue(( char*)abc,50);
        }

        printf("-- test");

		}
};
}
